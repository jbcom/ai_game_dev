"""
Pygame Game Development - Native Python implementation

This package provides native Python bindings for Pygame game development
integration with the AI Game Development ecosystem.
"""

import pygame
import json
from typing import List, Dict, Any
from dataclasses import dataclass
from enum import Enum


class GameType(Enum):
    TWO_DIMENSIONAL = "2d"
    THREE_DIMENSIONAL = "3d"  # Using pygame with OpenGL


class ComplexityLevel(Enum):
    BEGINNER = "beginner"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"


@dataclass
class GameSpec:
    name: str
    description: str
    game_type: GameType
    features: List[str]
    complexity: ComplexityLevel


@dataclass
class PygameProject:
    main_py: str
    game_py: str
    player_py: str
    constants_py: str
    requirements_txt: str
    assets: List[str]


def generate_pygame_project(spec: GameSpec) -> PygameProject:
    """Generate a complete Pygame project from a game specification."""
    
    main_py = generate_main_py(spec)
    game_py = generate_game_py(spec)
    player_py = generate_player_py(spec)
    constants_py = generate_constants_py(spec)
    requirements_txt = generate_requirements_txt(spec)
    assets = determine_required_assets(spec)
    
    return PygameProject(
        main_py=main_py,
        game_py=game_py,
        player_py=player_py,
        constants_py=constants_py,
        requirements_txt=requirements_txt,
        assets=assets
    )


def generate_main_py(spec: GameSpec) -> str:
    """Generate the main entry point file."""
    return f'''"""
{spec.name} - {spec.description}
Generated by AI Game Development system
"""

import pygame
import sys
from game import Game

def main():
    """Main entry point for {spec.name}."""
    pygame.init()
    
    try:
        game = Game()
        game.run()
    except Exception as e:
        print(f"Game error: {{e}}")
    finally:
        pygame.quit()
        sys.exit()


if __name__ == "__main__":
    main()
'''


def generate_game_py(spec: GameSpec) -> str:
    """Generate the main game class."""
    
    imports = ["import pygame", "from constants import *"]
    if "player" in spec.features or spec.complexity != ComplexityLevel.BEGINNER:
        imports.append("from player import Player")
    
    features_init = []
    features_update = []
    
    if "physics" in spec.features:
        features_init.append("        self.physics_enabled = True")
        features_update.append("        self.update_physics()")
    
    if "ai" in spec.features:
        features_init.append("        self.ai_entities = []")
        features_update.append("        self.update_ai()")
    
    if "audio" in spec.features:
        imports.append("import pygame.mixer")
        features_init.append("        pygame.mixer.init()")
        features_init.append("        self.load_audio()")
    
    return f'''"""
Game class for {spec.name}
"""

{chr(10).join(imports)}


class Game:
    """Main game class for {spec.name}."""
    
    def __init__(self):
        """Initialize the game."""
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption("{spec.name}")
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Initialize game features
{chr(10).join(features_init) if features_init else "        pass"}
        
        self.setup_game()
    
    def setup_game(self):
        """Setup game-specific initialization."""
        # Game setup based on: {spec.description}
        pass
    
    def run(self):
        """Main game loop."""
        while self.running:
            dt = self.clock.tick(FPS) / 1000.0
            
            self.handle_events()
            self.update(dt)
            self.draw()
    
    def handle_events(self):
        """Handle pygame events."""
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            elif event.type == pygame.KEYDOWN:
                self.handle_keydown(event)
    
    def handle_keydown(self, event):
        """Handle key press events."""
        if event.key == pygame.K_ESCAPE:
            self.running = False
    
    def update(self, dt):
        """Update game logic."""
{chr(10).join(features_update) if features_update else "        pass"}
    
    def draw(self):
        """Render the game."""
        self.screen.fill(BACKGROUND_COLOR)
        
        # Game-specific rendering
        self.render_game()
        
        pygame.display.flip()
    
    def render_game(self):
        """Render game-specific content."""
        pass
'''


def generate_player_py(spec: GameSpec) -> str:
    """Generate player class if needed."""
    
    if spec.game_type == GameType.THREE_DIMENSIONAL:
        # 3D player would need PyOpenGL integration
        position_type = "Vector3"
        default_pos = "[SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2, 0]"
    else:
        position_type = "List[int]"
        default_pos = "[SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2]"
    
    physics_methods = ""
    if "physics" in spec.features:
        physics_methods = '''
    def apply_force(self, force):
        """Apply physics force to player."""
        self.velocity[0] += force[0]
        self.velocity[1] += force[1]
    
    def update_physics(self, dt):
        """Update physics simulation."""
        # Apply gravity, friction, etc.
        self.velocity[1] += GRAVITY * dt
        
        # Update position
        self.position[0] += self.velocity[0] * dt
        self.position[1] += self.velocity[1] * dt
'''
    
    return f'''"""
Player class for {spec.name}
"""

import pygame
from constants import *
from typing import List


class Player:
    """Player character controller."""
    
    def __init__(self):
        """Initialize the player."""
        self.position: {position_type} = {default_pos}
        self.velocity: List[float] = [0.0, 0.0]
        self.speed: float = PLAYER_SPEED
        self.size: List[int] = [32, 32]
        
        # Load player sprite/assets
        self.load_assets()
    
    def load_assets(self):
        """Load player graphics and sounds."""
        # Placeholder for asset loading
        self.sprite = None
    
    def update(self, dt: float):
        """Update player logic."""
        self.handle_input()
        self.move(dt)
        {'self.update_physics(dt)' if 'physics' in spec.features else ''}
    
    def handle_input(self):
        """Handle player input."""
        keys = pygame.key.get_pressed()
        
        # Reset velocity for non-physics movement
        {'# Physics handles velocity' if 'physics' in spec.features else 'self.velocity = [0.0, 0.0]'}
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity[0] = -self.speed
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity[0] = self.speed
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity[1] = -self.speed
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity[1] = self.speed
    
    def move(self, dt: float):
        """Move the player."""
        self.position[0] += self.velocity[0] * dt
        self.position[1] += self.velocity[1] * dt
        
        # Keep player on screen
        self.position[0] = max(0, min(SCREEN_WIDTH - self.size[0], self.position[0]))
        self.position[1] = max(0, min(SCREEN_HEIGHT - self.size[1], self.position[1]))
    {physics_methods}
    
    def draw(self, screen):
        """Draw the player."""
        rect = pygame.Rect(self.position[0], self.position[1], self.size[0], self.size[1])
        pygame.draw.rect(screen, PLAYER_COLOR, rect)
'''


def generate_constants_py(spec: GameSpec) -> str:
    """Generate constants file."""
    
    constants = [
        "# Screen settings",
        "SCREEN_WIDTH = 800",
        "SCREEN_HEIGHT = 600",
        "FPS = 60",
        "",
        "# Colors (RGB)",
        "BLACK = (0, 0, 0)",
        "WHITE = (255, 255, 255)",
        "BLUE = (0, 100, 255)",
        "BACKGROUND_COLOR = BLACK",
        "PLAYER_COLOR = BLUE",
        "",
        "# Game settings",
        "PLAYER_SPEED = 200.0",
    ]
    
    if "physics" in spec.features:
        constants.extend([
            "",
            "# Physics settings",
            "GRAVITY = 500.0",
            "FRICTION = 0.8",
        ])
    
    if "audio" in spec.features:
        constants.extend([
            "",
            "# Audio settings", 
            "MUSIC_VOLUME = 0.7",
            "SFX_VOLUME = 0.8",
        ])
    
    return f'''"""
Constants for {spec.name}
"""

{chr(10).join(constants)}
'''


def generate_requirements_txt(spec: GameSpec) -> str:
    """Generate requirements.txt file."""
    requirements = ["pygame>=2.5.0"]
    
    if spec.game_type == GameType.THREE_DIMENSIONAL:
        requirements.append("PyOpenGL>=3.1.0")
        requirements.append("PyOpenGL_accelerate>=3.1.0")
    
    if "physics" in spec.features:
        requirements.append("pymunk>=6.5.0")
    
    if "ai" in spec.features:
        requirements.append("numpy>=1.21.0")
    
    return "\n".join(requirements) + "\n"


def determine_required_assets(spec: GameSpec) -> List[str]:
    """Determine required asset files."""
    assets = []
    
    # Graphics assets
    if spec.game_type == GameType.TWO_DIMENSIONAL:
        assets.extend([
            "assets/sprites/player.png",
            "assets/sprites/background.png",
        ])
    else:
        assets.extend([
            "assets/models/player.obj",
            "assets/textures/player.png",
        ])
    
    # Audio assets
    if "audio" in spec.features:
        assets.extend([
            "assets/audio/background_music.ogg", 
            "assets/audio/sound_effects.wav",
        ])
    
    return assets


def validate_pygame_project(project: PygameProject) -> bool:
    """Validate that generated Pygame project is syntactically correct."""
    try:
        # Test that all generated Python code compiles
        compile(project.main_py, "main.py", "exec")
        compile(project.game_py, "game.py", "exec")
        compile(project.player_py, "player.py", "exec")
        compile(project.constants_py, "constants.py", "exec")
        
        return True
    except SyntaxError:
        return False